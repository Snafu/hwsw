
%SYSTEM C

%				entwurfssprachen am bsp system c

\section{Allgemeines}
	Warum SystemC: \\
  \begin{itemize}
  	\item Systemdesign \& Verifikation HW / SW
  	\item Modellierung von Systemblöcken
  	\item Überblick über Interaktion der Funktionsblöcke
  	\item Entwicklung von embedd. Apps bevor Prototyp vorhanden ist
  	\item Design/Verifikation unabghängig von detailierter HW / SW Implementierung

  	\item Höherer Abstraktionslevel durch SystemC \\
			--> einfachere Tradeoffanalyse (Performance / Funktionalität) \\
			--> einfacheres Design / Redesign (Produktivitätssteigerung)
  \end{itemize}

\section{Geschichte}
	\begin{itemize}
	 \item 1997 Scenic (Vorgänger SystemC)
	 \item 1999 Open SystemC Inititive (ARM, Synopsis,...)
	 \item 2005 IEEE Standard IEEE 1666-2005 SystemC2.1
	\end{itemize}

	
\section{Sprachkonstrukte}
	SystemC ist eine C++ class library
	
	\subsection*{Module}
		\begin{itemize}
		  \item C++ Klasse sc\_module
			\item Grundlegende Einheit des Design
			\item Hierarchisches Design (Modul innerhalb von Modulen)
		\end{itemize}

	\subsection*{Processes (cooperative threading)}
		\begin{itemize}
			\item Enthalten die Funktion
			\item sc\_thread für einmalige Ausführung
			\item sc\_cthread (clocked thread, synthetisierbar - veraltet)
			\item sc\_method wird dauernd ausgeführt, kein wait-Status sondern next-Trigger
		\end{itemize}

	Ports/Interfaces/Channels/Exports

	Sensitivity, Events (Notification)
		bei welcher Signaländerung wird ein Process gestartet

	Hardwareorientierte Typen (mehrwertige Logik, Bitvektoren)

	\subsection{FIXME}
	 HW-Eigenschaften werden folgendermassen auf C++ Konzepte abgebildet
	\begin{itemize} 
	  \item Processes -> Funktionen
	  \item Interfaces -> Virtuelle Funktion
	  \item Interrupts -> Exception handling
	  \item Module -> Klasse
	  \item Architecture -> ... FIXME
	  \end{itemize}

\section{Beispiele}

	Anhand eines einfachen Hello World - Beispiels wurde die Funktionsweise eines sc\_thread demonstriert.

\section{Vor- \& Nachteile}
\subsection{Vorteile}
\begin{itemize}
 \item Unterstützung von Design in verschiedenen Abstraktionsleveln
 \item Design von HW/SW in einheitlicher Umgebung
 \item Leichteres debugging (SW statt HW)
 \item Verifikation wird vereinfacht (high level modell referenz)
 \item SystemC ist standardisiert
\end{itemize}

\subsection{Nachteile}
\begin{itemize}
 \item Grosser Sprachumfang (viel Ballast)
 \item Relativ neues Konzept
 \item Tools noch nicht ausgereift
 \item Wenig Fachkräfte
 \item Wenig vorhandene Projekte zur Orientierung
\end{itemize}



\subsection{vorhandene Tools}
\begin{itemize}
 \item Platform architect, VCS von Synopsis
 \item Modelsim von Mentor Graphics
\end{itemize}

\subsection{HW - Hersteller}
\begin{itemize}
 \item ARM11
 \item AMBA
\end{itemize}

\section{Verwendung}
\begin{itemize}
 \item Haupteinsatzgebiet von systemC ist an Unis
 \item Forschung im Vordergrund
 \item Entwicklung von kommerziellen Produkten steht nicht im Vordergrund
\end{itemize}

\section{SW-Sprachen}

\subsection{Besonderheiten}
\begin{itemize}
 \item HW-Erweiterungen unter Verwendung schon vorhandener Sprachkonzepte
 \item Automatische Partionierung
 \item Abbildung syncroner Komponenten in Software
 \item Abbildung asyncroner Komponenten in Hardware
\end{itemize}

